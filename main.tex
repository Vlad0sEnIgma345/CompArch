\input{style.tex}

\begin{document}
	
	\tableofcontents
	\newpage
	
	\section{Зависимости структурные, по данным и управлению. Способы преодоления зависимостей. Построение статической и динамической трассы исполнения команд.}
	\vspace{-1em}
	\subsection{Введение}
	\vspace{-0.5em}
	\textbf{Конвейеризация} -- это разбиение выполняемой функции на последовательные этапы (ступени), каждой из которых соответствует отдельный аппаратный блок.
	
	\vspace{-1em}
	\begin{figure}[H]
		\centering
		\includegraphics[width=1\linewidth, height=0.075\textheight]{img/01_01}
		\par
		{\small Разбиение процессора на блоки выполнения команд}
		\label{fig:01_01}
	\end{figure}
	\vspace{-1em}
	
	Команды проходят через эти блоки по тактам, при этом на разных ступенях одновременно обрабатываются разные команды. Если каждый этап занимает один такт, процессор выдает результат новой команды каждый такт. Такая организация значительно повышает производительность и широко используется в современных высокопроизводительных процессорах.
	\par\vspace{0.5em}
	\textbf{Конвейеризация} -- способ обеспечения параллельности выполнения команд.
	
	\textbf{Суперконвейер} -- это обычный конвейер, разбитый на более мелкие этапы. Он позволяет увеличить тактовую частоту процессора, но его длина ограничена рядом факторов. Основные ограничения связаны с зависимостями между командами, которые могут замедлять их продвижение по конвейеру.
	
	\par\vspace{0.5em}
	
	В зависимости от типа команды, вида способа адресации время выполнения 
	команды сильно варьируется. Дольше всего выполняются этапы, связанные с 
	обращением к памяти.
	
	\vspace{-1em}
	\begin{figure}[H]
		\centering
		\includegraphics[width=1\linewidth, height=0.175\textheight]{img/01_02}
		\par
		{\small Работа конвейера}
		\label{fig:01_02}
	\end{figure}
	\vspace{-1em}
	
	Конвейеризация повышает пропускную способность процессора (число команд, завершаемых за единицу времени), но не сокращает время выполнения одной команды. 
	\par 
	Эффективность ограничивается накладными расходами, связанными с несбалансированными задержками на ступенях: тактовая частота определяется самой медленной из них.
	
	\par\vspace{0.5em}
	\textbf{Поток команд} -- естественная последовательность команд, проходящая по конвейеру процессора. 
	\par
	Современные суперпроцессоры могут обрабатывать несколько потоков, если для каждого этапа предусмотрены отдельные исполнительные элементы.
	\par\vspace{0.5em}
	
	Максимальная эффективность достигается при высокой загрузке конвейера и равномерной подаче команд и данных (типично для RISC-процессоров). Задержки снижают производительность, особенно при возникновении \textbf{конфликтов}, которые делятся на три типа:
	
	\begin{enumerate}
		\item \textbf{Структурные} -- нехватка аппаратных ресурсов для одновременного выполнения команд.
		\item \textbf{По данным} -- одна команда зависит от результата предыдущей.
		\item \textbf{По управлению} -- связаны с переходами и изменением счётчика команд.
	\end{enumerate}
	
	При конфликтах конвейер частично останавливается: приостановка одной команды блокирует последующие, а новые команды не загружаются, что увеличивает среднее время выполнения.
	
	\newpage
	
	\subsection{Структурные зависимости}
	
	Появляются из-за недостаточности ресурсов. 
	\par 
	\textbf{\uline{Пример}}: наличие единственного конвейера доступа к памяти как для команд, так и для данных. 
	\par
	Это приводит к конфликту, если:
	\vspace{-0.35em}
	\begin{itemize}
		\item одна команда обращается к памяти за данными,
		\item в то же время происходит выборка следующей команды из памяти.
	\end{itemize}
	\vspace{-0.5em}
	\textbf{\uline{Решение}}:
	\vspace{-0.35em}
	\begin{itemize}
		\item приостановка конвейера на один такт -- \textbf{вставка конвейерного пузыря (pipeline bubble)}.
	\end{itemize}
	\vspace{-1.5em}
	\subsection{Зависимости по данным}
	
	Связаны с использованием одних и тех же ресурсов (регистров, ячеек памяти) в разных инструкциях.
	
	\textbf{\uline{Классификация зависимостей по данным:}}
	
	\begin{itemize}
		\item \textbf{RAW (Read After Write)} – чтение после записи (\textit{наиболее общий и важный тип конфликтов}). 
		\par
		Инструкция пытается прочитать значение до того, как предыдущая завершит запись. 
		\par
		\item \textbf{WAR (Write After Read)} – запись после чтения. 
		\par
		Инструкция записывает значение раньше, чем другая инструкция успела его прочитать.
		\item \textbf{WAW (Write After Write)} – запись после записи. 
		\par
		Две инструкции записывают в один и тот же регистр, но порядок записи нарушен.
		\item \textbf{RAR (Read After Read)} – чтение после чтения. 
		\par
		Не приводит к конфликтам и может быть проигнорировано.
	\end{itemize}
	
	\textbf{\uline{Типичная ситуация}}:

	\begin{itemize}
		\item Команда B использует результат команды A, но команда A еще не завершила выполнение.
		\item Если продолжить выполнение без доп. мер, B может использовать некорректные данные.
	\end{itemize}
	
	\textbf{\uline{Методы разрешения конфликтов}}:
	
	\begin{enumerate}
		\item \textbf{Обходы (data bypassing) / закоротки (short-circuiting)}
			\begin{itemize}
				\item Результат выхода АЛУ возвращается напрямую на его вход, т.е. выбирается значение, 
				\par
				идущее по цепи обхода, минуя регистровый файл.
				\item Применимо к случаям RAW-зависимости между двумя операциями АЛУ.
			\end{itemize}
		\item \textbf{Внутренние блокировки (pipeline interlock)}:
		\begin{itemize}
			\item Используется в случае, когда обход невозможен
			\par
			\textbf{\uline{Пр.}:} после команды \texttt{LW} (имеет задержку и не может быть решена обычной ``пересылкой'').
			\item Аппаратура автоматически приостанавливает выполнение последующих инструкций.
			\item Возникает ``пузырь'' в конвейере.
		\end{itemize}
	\end{enumerate}
	Сейчас компиляторы применяют планирование команд для повышения эффективности конвейера.
	\par
	\textbf{Базовый блок} -- линейная последовательность без переходов. Позволяет минимизировать простои. 
	\par
	В простом случае команды упорядочиваются внутри базового блока с учётом графа зависимостей.
	\par
	Планирование упрощается, т.к. выполнение блока команд зависит от выполнения первой команды.
	\newpage
	Однако, требуются более сложные алгоритмы планирования. Они базируются на следующих методах:
	\begin{enumerate}[start=3]
		\item \textbf{Динамическая оптимизация (``out-of-order execution'' - неупорядоченное выполнение)}:
		\begin{itemize}
			\item Буферизация конфликтующих команд.
			\item Продолжение выполнения других независимых инструкций в ``обход'' буфера.
			\item Передача результата в зависимую команду или на вход устройства, минуя запись в регистр.
		\end{itemize}
		\item \textbf{Переименование регистров (register renaming)}:
		\begin{itemize}
			\item Используются логические и физические регистры.
			\item Логические регистры отображаются на физические с помощью таблиц отображения.
			\item Каждый новый результат сохраняется в новый физический регистр.
			\item Предыдущее значение сохраняется для возможного отката.
			\item Временные значения фиксируются после завершения команды.
			\item Устраняются зависимости WAW и WAR.
			\item Программист работает только с логическими регистрами.
			\item Позволяет избежать конфликтов за один и тот же логический регистр.
		\end{itemize}
	\end{enumerate}
	
	\subsection{Зависимости по управлению}
	
	Возникают из-за наличия условных переходов в программе. 
	\par
	\textbf{\uline{Пример}}:
	
	\begin{itemize}
		\item Выполнение команды B зависит от результата команды A.
	\end{itemize}
	
	\textbf{\uline{Причины}}:
	
	\begin{itemize}
		\item Управляющие конструкции: \texttt{if}, \texttt{while}, \texttt{for}.
	\end{itemize}
	
	\textbf{\uline{Методы снижения влияния}}:
	
	\begin{itemize}
		\item \textbf{Реорганизация кода} -- минимизация зависимостей.
		\item \textbf{Асинхронные операции} -- продолжение выполнения без ожидания.
		\item \textbf{Кэширование} -- повторное использование результатов операций.
	\end{itemize}
	
	\textbf{Существуют два вида переходов}:
	
	\begin{enumerate}
		\item \textbf{Безусловные} -- всегда выполняются.
		\item \textbf{Условные} -- выполняются в зависимости от результата сравнения.
	\end{enumerate}
	
	\textbf{\uline{Проблема}}: Нельзя заранее узнать, выполнится ли условный переход, до окончания его выполнения. 
	\par
	Чтобы не терять такты при ожидании прохождения команды исполнительной ступени конвейера, используется предсказание. При верном -- выполнение продолжается, при ошибке -- конвейер очищается и перезапускается с нужного адреса.
	\par
	Есть простые способы уменьшить задержки конвейера, вызванные условными переходами:
	
	\textbf{\uline{Решения}}:
	
	\begin{enumerate}[leftmargin=2em]
		\item \textbf{Метод выжидания} -- заморозка конвейера до определения направления перехода путем \uline{блокировки} выполнения любой команды за командой условного перехода до определения его направления.
		\item \textbf{Метод возврата (предсказание как \uline{невыполняемого})} -- продолжение исполнения, как будто переход не произойдет. Состояние машины \uline{не изменяется} до определения направления перехода.
		\item \textbf{Задержанные переходы (delayed branch)} -- выполнение перехода \uline{с задержкой}, в течение которой исполняются другие команды. Эти команды находятся в слотах (временных интервалах) задержанного перехода.
	\end{enumerate}
	
	\newpage
	
	\subsection{Методы предсказания переходов}
	
	\subsubsection{Статическое предсказание (static prediction)}
	
	Осуществляется в основном \uline{до выполнения программы}:
	
	\begin{itemize}[leftmargin=2.25em]
		\item \textbf{На этапе компиляции}:
		\begin{itemize}[leftmargin=1.35em]
			\item Метод \uline{исследования структуры} программы (её анализ).
			\item Метод \uline{использования профиля выполнения} программы (\uline{трассировка} предыдущих запусков).
			\par
			$\bullet$ Компилятор устанавливает флаг, указывающий направление перехода.
		\end{itemize}
		\item \textbf{На этапе выполнения}:
		\begin{itemize}[leftmargin=1.35em]
			\item Применение заранее заданных правил (пример: предположение, что переход назад -- цикл).
		\end{itemize}
	\end{itemize}
	
	\subsubsection{Динамическое предсказание (dynamic prediction)}
	
	Происходит во время исполнения программы и основано на анализе истории ветвлений.
	
	\begin{enumerate}[leftmargin=1.35em]
		\item \textbf{Метод прогнозирования условных переходов}
		\par
		Используется \textbf{буфер предсказания (таблица ``истории'') условных переходов}:
		\begin{itemize}
			\item Небольшая память (таблица), индексируемая по младшим битам адреса команды перехода.
			\item Каждая ячейка содержит бит, указывающий, был ли предыдущий переход выполнен.
			\item \uline{Однобитовая схема} -- прогноз меняется сразу при ошибке, что плохо для циклов.
			\item \uline{Двухбитовая схема} -- прогноз меняется только после двух ошибок, что повышает точность.
			\item Возможны более сложные n-битовые и коррелированные схемы, учитывающие историю нескольких переходов.
		\end{itemize}
		
		\item \textbf{Метод быстрого определения адреса перехода}
		\par
		Используется \textbf{буфер целевых адресов переходов (branch target buffer)}:
		\begin{itemize}
			\item Кэш хранит адреса следующих команд для переходов.
			\item Позволяет быстро определять адрес следующей команды и сокращать задержки.
			\item Используется вместе \uline{с буфером предсказания} для мгновенного выбора ветви.
		\end{itemize}
		
		\item \textbf{Метод свертывания переходов (branch folding)}
		\par
		Используется \textbf{буфер целевых адресов переходов (branch target buffer)}:
		\begin{itemize}
			\item Хранит команды из прогнозируемой ветви внутри процессора.
			\item Позволяет уменьшить время выполнения безусловных и некоторых условных переходов.
			\item Может работать и самостоятельно -- \uline{без буфера целевых адресов}.
		\end{itemize}
		
		\item \textbf{Метод прогнозирования косвенных переходов}
		\par
		Используется \textbf{небольшой буфер адресов возврата, работающий как стек}:
		\begin{itemize}
			\item Косвенные переходы меняют адрес назначения во время выполнения -- в run-time 
			\par
			(например, возвраты из процедур).
			\item Буфер хранит последние адреса возврата и \uline{точно прогнозирует} следующий адрес.
		\end{itemize}
	\end{enumerate}
	
	\newpage
	
	\subsection{Трассы исполнения команд}
	
	\subsubsection{Статическая трасса исполнения}
	
	Создаётся на основе анализа исходного кода \uline{без его фактического выполнения}.
	
	\textbf{Используется для:}
	
	\begin{itemize}
		\item Оптимизации кода.
		\item Выявления потенциальных проблем.
	\end{itemize}
	
	\textbf{Включает:}
	
	\begin{itemize}
		\item Анализ потока управления.
		\item Анализ зависимостей данных.
	\end{itemize}
	
	\textbf{Пример:}
	\begin{itemize}
		\item Определяются места использования переменных и порядок исполнения инструкций.
	\end{itemize}
	
	\subsubsection{Динамическая трасса исполнения}
	
	Формируется \uline{во время выполнения} программы.
	
	\textbf{Используется для:}
	
	\begin{itemize}
		\item Профилирования.
		\item Отладки.
	\end{itemize}
	
	\textbf{Включает:}
	\begin{itemize}
		\item Последовательность реально выполненных инструкций.
		\item Фактические зависимости и данные, участвующие в исполнении.
	\end{itemize}
	
	\textbf{Пример:}
	\begin{itemize}
		\item Регистрируются команды, порядок их выполнения и используемые данные.
	\end{itemize}
	
	\textbf{Сравнение трасс позволяет:}
	\begin{itemize}
		\item Сравнение статической и динамической трасс позволяет выявить отклонения фактического выполнения от ожидаемого поведения, что помогает в отладке и оптимизации кода.
	\end{itemize}
	
	\textbf{Понимание типов зависимостей и методов их устранения позволяет:}
	\begin{itemize}
		\item Повысить производительность конвейерной архитектуры.
		\item Эффективно использовать ресурсы процессора.
		\item Оптимизировать исполняемый код на этапах компиляции и исполнения.
	\end{itemize}
	
	\newpage
	
	\section{Схемы основных мультипроцессорных архитектур (UMA, NUMA, векторная, сетевая, кластерная). Гранулярность. Классификация Флинна.}
	
	\section{Дискретизация аналогового сигнала. Эффекты дискретизации. Теорема Котельникова.}
	
	\section{Фотоприемники на приборах с зарядовой связью (ФПЗС). КМОП-фотоприемники. Схемы пикселей и их работа.}
	
	\section{Магнитные диски.  Технология записи.  Логическое и физическое форматирование. FAT. NTFS.}
	
\end{document}